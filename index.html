<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ML5.js Handpose</title>
  <script src="./p5@1.11.1.min.js"></script>
  <script src="./ml5@1.2.1.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <script>
    let video;
    let handPose;
    let bodyPose;
    let faceMesh;
    let hands;
    let bodies;
    let faces;
    let debugMode = false;

    let gameState = {
      started: false,
      playing: false,
      level: 1,
      ended: false,
      countdown: false,
      countdownStartTime: 0,
      levelStartTime: 0,
      scores: {},
      totalScore: 0,
      progressHistory: [], // Array to store recent progress values
      progressHistorySize: 5 // Number of frames to average
    };

    let levels = [
      {
        progressFunction: (metrics) => {
          if (!metrics.handsOverHead.calced) {
            return null;
          }
          // this would go from about -200 to 200, if head in center (and screen is 400 tall),
          // so let's say < -100 is 0, > 100 is 1, and in between is linear.
          const progress = Math.min(1, Math.max(0, (metrics.handsOverHead.twoD + 100) / 200));
          return progress;
        },
      },
      {
        progressFunction: (metrics) => {
          if (!metrics.leftHandPinch.calced) {
            return null;
          }

          // range is about 1 - 15.
          // want to say < 4 is 1, > 10 is 0, and in between is linear.
          if (metrics.leftHandPinch.threeD <= 4) {
            return 1;
          } else if (metrics.leftHandPinch.threeD > 10) {
            return 0;
          } else {
            return 1 - (metrics.leftHandPinch.threeD - 4) / 6;
          }
        },
      },
      {
        progressFunction: (metrics) => {
          if (!metrics.mouthOpen.calced || !metrics.wrists.calced) {
            return null;
          }

          // half the score is mouth open, half is wrists.

          // mouth open is around 20 - 120, so let's say < 30 is 0, > 100 is 1, and in between is linear.
          const mouthProgress = Math.min(1, Math.max(0, (metrics.mouthOpen.ratio - 30) / 70));

          // wrists are 10 - 70, so let's say < 20 is 0, > 60 is 1, and in between is linear.
          const wristProgress = Math.min(1, Math.max(0, 1 - (metrics.wrists.threeD - 20) / 40));

          return (mouthProgress + wristProgress) / 2;
        },
      }
    ]

    function preload() {
      // TODO at least faceMesh has a maxFaces option, which would be nice to use
      // (and show error message around??)
      handPose = ml5.handPose({ flipped: true });
      bodyPose = ml5.bodyPose("BlazePose", { flipped: true });
      faceMesh = ml5.faceMesh({ flipped: true, refineLandmarks: true });
    }

    function setup() {
      createCanvas(640, 480);

      // Create video and hide it
      video = createCapture(VIDEO, { flipped: true });
      video.size(640, 480);
      video.hide();

      handPose.detectStart(video, gotHands);
      bodyPose.detectStart(video, gotBodies);
      faceMesh.detectStart(video, gotFaces);

      // Set text to bold by default
      textStyle(BOLD);
      
      resetGame();
    }

    function gotHands(results) {
      hands = results;
    }

    function gotBodies(results) {
      bodies = results;
    }

    function gotFaces(results) {
      faces = results;
    }

    function computeMetrics() {
      const metrics = {
        leftHandPinch: {
          title: "Left Hand Pinch",
          calced: false,
        },
        rightHandPinch: {
          title: "Right Hand Pinch",
          calced: false,
        },
        wrists: {
          title: "Wrists",
          calced: false
        },
        mouthOpen: {
          title: "Mouth Open",
          calced: false
        },
        eyebrowRaised: {
          title: "Eyebrow Raised",
          calced: false
        },
        handsOverHead: {
          title: "Hands Over Head",
          calced: false
        },
      };

      if (hands) {
        for (let i = 0; i < hands.length; i++) {
          const hand = hands[i];
          const thumbTip = hand?.thumb_tip;
          const indexTip = hand?.index_finger_tip;

          if (hand.confidence > 0.9 && thumbTip && indexTip) {
            if (hand.handedness === "Left") {
              metrics.leftHandPinch.calced = true;
              metrics.leftHandPinch.twoD = calculate2DDistance(thumbTip, indexTip);
              metrics.leftHandPinch.threeD = calculateHand3DDistance(thumbTip, indexTip);
            } else if (hand.handedness === "Right") {
              metrics.rightHandPinch.calced = true;
              metrics.rightHandPinch.twoD = calculate2DDistance(thumbTip, indexTip);
              metrics.rightHandPinch.threeD = calculateHand3DDistance(thumbTip, indexTip);
            }
          }
        }
      }

      if (bodies && bodies.length > 0) {
        const body = bodies[0];
        const leftWrist = body?.left_wrist;
        const rightWrist = body?.right_wrist;

        if ((leftWrist && leftWrist.confidence > 0.5) && (rightWrist && rightWrist.confidence > 0.5)) {
          metrics.wrists.calced = true;
          metrics.wrists.twoD = calculate2DDistance(leftWrist, rightWrist);
          metrics.wrists.threeD = calculateBody3DDistance(leftWrist, rightWrist);
        }

        const nose = body?.nose;

        if ((nose && nose.confidence > 0.9) && (leftWrist && leftWrist.confidence > 0.9) && (rightWrist && rightWrist.confidence > 0.9)) {
          metrics.handsOverHead.calced = true;

          // this one is easiest as just 2d height on screen
          const averageWristHeight = (leftWrist.y + rightWrist.y) / 2;
          metrics.handsOverHead.twoD = nose.y - averageWristHeight;
        }

      }

      if (faces && faces.length > 0) {
        const face = faces[0];
        // if (Math.random() < 0.1) {
        //   console.log(face);
        // }
        // console.log(face);

        // it's a little tricky to get a 3d distance for the face,
        // because the points are always given x/y/z which I'm not really sure how to make sense of.
        // but the effect is that using the 3d distance seems to scale when I approach camera,
        // which is not what I want. instead, I'll use the ratio of height of lips to width of lips
        // to get a sense of open/closed.
        if (face.lips) {
          metrics.mouthOpen.calced = true;
          metrics.mouthOpen.ratio = face.lips?.height / face.lips?.width * 100.;
        }

        // TODO note this doesn't really work yet. rotating the head screws it up dramatically,
        // which I think is because x / y are projections onto the screen (how we're seeing them...)
        // I think I need to read more about how to project them into space.
        // mouth seems to have this issue to a much lesser degree.
        if (face.leftEye && face.rightEye) {
          // yipes. these are using indexes from: https://github.com/lschmelzeisen/understanding-mediapipe-facemesh-output/tree/main
          const rightEyeInsideCorner = face.keypoints[133];
          const rightEyeOutsideCorner = face.keypoints[33];
          const rightEye = calculateFaceAveragePoint(rightEyeInsideCorner, rightEyeOutsideCorner);
          const rightEyebrowMidInside = face.keypoints[65];
          const rightEyebrowMidOutside = face.keypoints[52];
          const rightEyebrow = calculateFaceAveragePoint(rightEyebrowMidInside, rightEyebrowMidOutside);
          const rightEyebrowDist = calculateFace3DDistance(rightEyebrowMidInside, rightEyebrowMidOutside);

          const leftEyeInsideCorner = face.keypoints[362];
          const leftEyeOutsideCorner = face.keypoints[263];
          const leftEye = calculateFaceAveragePoint(leftEyeInsideCorner, leftEyeOutsideCorner);
          const leftEyebrowMidInside = face.keypoints[295];
          const leftEyebrowMidOutside = face.keypoints[282];
          const leftEyebrow = calculateFaceAveragePoint(leftEyebrowMidInside, leftEyebrowMidOutside);
          const leftEyebrowDist = calculateFace3DDistance(leftEyebrowMidInside, leftEyebrowMidOutside);

          // console.log({rightEyebrowDist, leftEyebrowDist});

          metrics.eyebrowRaised.ratio = leftEyebrowDist / rightEyebrowDist * 100;
          metrics.eyebrowRaised.calced = true;
        }
      }

      return metrics;
    }

    function drawAllPoints() {
      if (hands) {
        for (let i = 0; i < hands.length; i++) {
          const hand = hands[i];
          drawKeypoints(hand);
          drawHandSkeleton(hand);
        }
      }
      if (bodies) {
        for (let i = 0; i < bodies.length; i++) {
          const body = bodies[i];
          drawKeypoints(body);
        }
      }
      if (faces) {
        for (let i = 0; i < faces.length; i++) {
          const face = faces[i];
          // drawKeypoints(face.lips);
          // drawKeypoints(face.leftEye);
          // drawKeypoints(face.leftEyebrow);
        }
      }
    }

    function drawAllMetrics(metrics) {
      const metricStrs = [];
      for (const key in metrics) {
        const metric = metrics[key];
        if (metric.calced) {
          metricStr = "";
          if (metric.twoD) {
            metricStr += "2D: " + Math.round(metric.twoD) + "; ";
          }
          if (metric.threeD) {
            metricStr += "3D: " + Math.round(metric.threeD);
          }
          if (metric.ratio) {
            metricStr += "Ratio: " + Math.round(metric.ratio);
          }
          metricStrs.push(metric.title + ": " + metricStr);
        } else {
          metricStrs.push(metric.title + ": Not available");
        }
      }

      drawDistanceBox(metricStrs);
    }

    function draw() {
      image(video, 0, 0, width, height);

      const metrics = computeMetrics();

      // Only show debugging info if debug mode is enabled
      if (debugMode) {
        drawAllMetrics(metrics);
        drawAllPoints();
      }

      // Reset text style to bold for game UI after potential debug drawing
      textStyle(BOLD);
      
      // Add overlay for text readability when needed
      if (!gameState.playing) {
        // Simple semi-transparent dark overlay
        fill(0, 0, 0, 150);
        noStroke();
        rect(0, 0, width, height);
      }

      // console.log(gameState)

      // show game state
      if (!gameState.started) {
        // Title and start screen - more understated
        push();
        fill(255);
        textSize(42);
        textAlign(CENTER, CENTER);
        text("PROPRIOCEPTION", width / 2, height / 2 - 30);
        
        // Instructions - simple white text
        textSize(24);
        text("Press any key to start", width / 2, height / 2 + 40);
        
        // Debug info - smaller and less obtrusive
        // textSize(14);
        // fill(180, 180, 180);
        // text("Press 'D' to toggle debug view", width / 2, height - 20);
        pop();
      } else if (gameState.ended) {
        // Game over screen - more understated
        push();
        fill(255);
        textSize(28);
        textAlign(CENTER, CENTER);
        text("Game Complete", width / 2, height / 2 - 80);
        
        // Display scores in a clean, minimal format
        noStroke();
        
        textSize(20);
        textAlign(RIGHT, CENTER);
        text("LEVEL", width/2 - 100, height/2 - 40);
        text("TIME", width/2 + 100, height/2 - 40);
        
        // Display scores for each level
        fill(255);
        textSize(18);
        let scoreY = height / 2;
        
        for (let level in gameState.scores) {
          textAlign(RIGHT, CENTER);
          text(level, width/2 - 100, scoreY);
          textAlign(LEFT, CENTER);
          text(gameState.scores[level] + " sec.", width/2 + 20, scoreY);
          scoreY += 26;
        }
        
        // Display total score - aligned with level scores
        fill(255);
        textSize(18);
        textAlign(RIGHT, CENTER);
        text("TOTAL", width/2 - 100, scoreY);
        textAlign(LEFT, CENTER);
        text(gameState.totalScore + " sec.", width/2 + 20, scoreY);
        
        // Add instruction to press key to restart (positioned at fixed distance from bottom)
        textSize(18);
        text("Press any key to play again", width / 2, height - 40);
        pop();
      } else if (gameState.countdown) {
        // Handle countdown
        const elapsedTime = millis() - gameState.countdownStartTime;
        const countdownSeconds = 3 - Math.floor(elapsedTime / 1000);
        
        if (countdownSeconds <= 0) {
          // Countdown finished, start level
          gameState.countdown = false;
          startLevel();
        } else {
          push();
          // Level title - simple, clean
          fill(255);
          textSize(24);
          textAlign(CENTER, CENTER);
          text("Level " + gameState.level, width / 2, height / 2 - 40);
          
          // Countdown number - simple, no effects
          textSize(60);
          text(countdownSeconds, width / 2, height / 2 + 20);
          pop();
        }
      } else if (!gameState.playing) {
        push();
        // Level intro screen - minimal
        fill(255);
        textSize(28);
        textAlign(CENTER, CENTER);
        text("Level " + gameState.level, width / 2, height / 2 - 40);
        
        // Display description based on level
        textSize(20);
        
        if (gameState.level === 1) {
          text("Raise your hands above your head", width / 2, height / 2 + 10);
        } else if (gameState.level === 2) {
          text("Pinch your left thumb and index finger", width / 2, height / 2 + 10);
        } else if (gameState.level === 3) {
          text("Open your mouth and bring your wrists together", width / 2, height / 2 + 10);
        }
        
        // Start instructions
        textSize(18);
        text("Press any key to begin", width / 2, height / 2 + 60);
        pop();
      } else {
        // Get level from array (0-indexed)
        const levelIndex = gameState.level - 1;
        const level = levels[levelIndex];
        const progressFunction = level.progressFunction;
        const rawProgress = progressFunction(metrics);
        
        // Apply smoothing to progress value
        const smoothedProgress = smoothProgress(rawProgress);
        const progress = smoothedProgress;
        
        if (progress >= 1) {
          if (levelIndex < levels.length - 1) {
            nextLevel();
          } else {
            endGame();
          }
          return;
        }
        // Display level and current time - minimal design
        const currentTime = ((millis() - gameState.levelStartTime) / 1000).toFixed(1);
        
        // Simple text without box
        push();
        fill(255);
        textSize(20);
        textAlign(LEFT, TOP);
        text("Level " + gameState.level + " â€¢ " + currentTime + "s", 20, 20);
        pop();
        
        if (progress != null) {
          // Show progress bar
          textSize(32);
          textAlign(CENTER, CENTER);
          drawProgressBar(progress);
        } else {
          fill(255);
          textSize(32);
          textAlign(CENTER, CENTER);
          text("Relevant body parts not detected", width / 2, height / 2);
        }
      }
    }

    // Removed overlay functions to fix visual issues
    
    function drawProgressBar(progress) {
      const barWidth = 300;
      const barHeight = 8;
      const barX = (width - barWidth) / 2;
      const barY = height - 40;

      // Draw background
      push();
      noStroke();
      fill(255, 255, 255, 40);
      rect(barX, barY, barWidth, barHeight, 4);

      // Draw the progress bar - simple, modern
      fill(255);
      rect(barX, barY, barWidth * progress, barHeight, 4);
      pop();
    }

    function drawKeypoints(obj) {
      for (let j = 0; j < obj.keypoints.length; j++) {
        let keypoint = obj.keypoints[j];
        if (keypoint.confidence < 0.9) {
          continue;
        }
        fill(0, 255, 0);
        noStroke();
        circle(keypoint.x, keypoint.y, 10);
      }
    }
    function calculate2DDistance(point1, point2) {
      const dx = point1.x - point2.x;
      const dy = point1.y - point2.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function calculateHand3DDistance(point1, point2) {
      const dx = point1.x3D - point2.x3D;
      const dy = point1.y3D - point2.y3D;
      const dz = point1.z3D - point2.z3D;
      return Math.sqrt(dx * dx + dy * dy + dz * dz) * 100.;
    }

    function calculateBody3DDistance(point1, point2) {
      const dx = point1.keypoint3D.x - point2.keypoint3D.x;
      const dy = point1.keypoint3D.y - point2.keypoint3D.y;
      const dz = point1.keypoint3D.z - point2.keypoint3D.z;
      return Math.sqrt(dx * dx + dy * dy + dz * dz) * 100.;
    }

    function calculateFace3DDistance(point1, point2) {
      // I think this is a little funny, or at least maybe should only be used for ratios.
      // not sure how to interpret z.
      const dx = point1.x - point2.x;
      const dy = point1.y - point2.y;
      const dz = point1.z - point2.z;
      return Math.sqrt(dx * dx + dy * dy + dz * dz) * 100.;
    }

    function calculateFaceAveragePoint(point1, point2) {
      const x = (point1.x + point2.x) / 2;
      const y = (point1.y + point2.y) / 2;
      const z = (point1.z + point2.z) / 2;
      return { x, y, z };
    }

    // function calculateFace3DDistance(point1, point2) {
    //   const dx = point1.x - point2.x;
    //   const dy = point1.y - point2.y;
    //   const dz = point1.z - point2.z;
    //   return Math.sqrt(dx * dx + dy * dy + dz * dz) * 100.;
    // }

    function drawDistanceBox(distanceStrs) {
      // Box parameters
      const padding = 10;
      const lineHeight = 16; // Smaller line height for smaller text
      const boxWidth = 300;
      const boxHeight = padding * 2 + lineHeight * distanceStrs.length;
      const boxX = 20;
      const boxY = 20;

      // Draw box with semi-transparent background
      push();
      fill(0, 0, 0, 230);    // More opaque background
      stroke(255, 255, 0);   // Yellow border
      strokeWeight(3);       // Thicker border
      rect(boxX, boxY, boxWidth, boxHeight, 10);  // Rounded corners

      // Draw text - not bold and smaller
      fill(255);             // White text
      noStroke();
      textStyle(NORMAL);     // Non-bold text for metrics
      textSize(14);          // Smaller text size
      textAlign(LEFT, TOP);

      // Show each distance string
      for (let i = 0; i < distanceStrs.length; i++) {
        text(distanceStrs[i], boxX + padding, boxY + padding + i * lineHeight);
      }
      pop();
    }

    function drawHandSkeleton(hand) {
      // Define finger connections
      const fingerConnections = [
        // Thumb [connections]
        [0, 1, 2, 3, 4],
        // Index finger 
        [0, 5, 6, 7, 8],
        // Middle finger
        [0, 9, 10, 11, 12],
        // Ring finger
        [0, 13, 14, 15, 16],
        // Pinky
        [0, 17, 18, 19, 20]
      ];

      // Define colors for each finger
      const colors = [
        [255, 0, 0],      // thumb (red)
        [0, 255, 0],      // index (green)
        [0, 0, 255],      // middle (blue)
        [255, 255, 0],    // ring (yellow)
        [255, 0, 255]     // pinky (magenta)
      ];

      // Draw each finger
      for (let i = 0; i < fingerConnections.length; i++) {
        const points = fingerConnections[i];
        const color = colors[i];

        stroke(color[0], color[1], color[2]);
        strokeWeight(2);

        // Draw lines connecting each point in the finger
        for (let j = 0; j < points.length - 1; j++) {
          const keypoint1 = hand.keypoints[points[j]];
          const keypoint2 = hand.keypoints[points[j + 1]];

          if (keypoint1 && keypoint2) {
            line(keypoint1.x, keypoint1.y, keypoint2.x, keypoint2.y);
          }
        }
      }
    }

    function smoothProgress(rawProgress) {
      // Handle null value
      if (rawProgress === null) {
        gameState.progressHistory = []; // Clear history when detection is lost
        return null;
      }
      
      // Add current value to history
      gameState.progressHistory.push(rawProgress);
      
      // Limit history size
      if (gameState.progressHistory.length > gameState.progressHistorySize) {
        gameState.progressHistory.shift(); // Remove oldest value
      }
      
      // Calculate weighted average (more recent values have more weight)
      let totalWeight = 0;
      let weightedSum = 0;
      
      for (let i = 0; i < gameState.progressHistory.length; i++) {
        // Weight increases with index (newer values get higher weights)
        const weight = i + 1;
        weightedSum += gameState.progressHistory[i] * weight;
        totalWeight += weight;
      }
      
      return weightedSum / totalWeight;
    }
    
    function resetGame() {
      gameState.started = false;
      gameState.level = 1;
      gameState.ended = false;
      gameState.countdown = false;
      gameState.playing = false;
      gameState.scores = {};
      gameState.totalScore = 0;
      gameState.progressHistory = [];
    }

    function startGame() {
      gameState.started = true;
    }

    function endGame() {
      // Calculate score for final level
      const levelTime = (millis() - gameState.levelStartTime) / 1000;
      gameState.scores[gameState.level] = levelTime.toFixed(2);
      gameState.totalScore += parseFloat(levelTime);
      gameState.totalScore = gameState.totalScore.toFixed(2); // Format total to 2 decimal places
      
      gameState.playing = false; // Make sure playing is set to false
      gameState.ended = true;
    }

    function startLevel() {
      gameState.playing = true;
      gameState.levelStartTime = millis();
      gameState.progressHistory = []; // Reset progress history for new level
    }

    function startCountdown() {
      gameState.countdown = true;
      gameState.countdownStartTime = millis();
    }

    function nextLevel() {
      // Calculate and store score for the completed level
      const levelTime = (millis() - gameState.levelStartTime) / 1000; // Convert to seconds
      gameState.scores[gameState.level] = levelTime.toFixed(2);
      gameState.totalScore += parseFloat(levelTime);
      
      // Move to next level
      gameState.level++;
      gameState.playing = false;
      startCountdown();
    }

    function restartGame() {
      resetGame();
      startGame();
      startCountdown();
    }
    
    function keyPressed() {
      // Toggle debug mode with 'd' key regardless of game state
      if (key === 'd' || key === 'D') {
        debugMode = !debugMode;
        return;
      }
      
      // Handle restart after game over
      if (gameState.ended) {
        restartGame();
        return;
      }
      
      // Don't proceed if already playing or counting down
      if (gameState.playing || gameState.countdown) {
        return;
      }
      
      // Starting a new game or level
      if (!gameState.started) {
        startGame();
        startCountdown();
      } else {
        startCountdown();
      }
    }
  </script>
</body>

</html>
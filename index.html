<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ML5.js Handpose</title>
  <script src="./p5@1.11.1.min.js"></script>
  <script src="./ml5@1.2.1.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <script>
    let video;
    let handPose;
    let bodyPose;
    let faceMesh;
    let hands;
    let bodies;
    let faces;
    let debugMode = false;

    // Global metrics definition with score calculation functions
    const metricsDefinition = {
      leftHandPinch: {
        title: "Left Hand Pinch",
        calculateScore: function(metric) {
          if (!metric.calced) return null;
          
          // range is about 1 - 15
          // < 4 is score 1, > 10 is score 0, and in between is linear
          if (metric.threeD <= 4) {
            return 1;
          } else if (metric.threeD > 10) {
            return 0;
          } else {
            return 1 - (metric.threeD - 4) / 6;
          }
        }
      },
      rightHandPinch: {
        title: "Right Hand Pinch",
        calculateScore: function(metric) {
          if (!metric.calced) return null;
          
          // range is about 1 - 15
          // < 4 is score 1, > 10 is score 0, and in between is linear
          if (metric.threeD <= 4) {
            return 1;
          } else if (metric.threeD > 10) {
            return 0;
          } else {
            return 1 - (metric.threeD - 4) / 6;
          }
        }
      },
      wrists: {
        title: "Wrists",
        calculateScore: function(metric) {
          if (!metric.calced) return null;
          
          // wrists are 10 - 70
          // < 20 is score 0, > 60 is score 1, and in between is linear
          return Math.min(1, Math.max(0, 1 - (metric.threeD - 20) / 40));
        }
      },
      mouthOpen: {
        title: "Mouth Open",
        calculateScore: function(metric) {
          if (!metric.calced) return null;
          
          // mouth open is around 20 - 120
          // < 30 is score 0, > 100 is score 1, and in between is linear
          return Math.min(1, Math.max(0, (metric.ratio - 30) / 70));
        }
      },
      eyebrowRaised: {
        title: "Eyebrow Raised",
        calculateScore: function(metric) {
          if (!metric.calced) return null;
          
          // Not currently used in levels, placeholder for future use
          return 0;
        }
      },
      handsOverHead: {
        title: "Hands Over Head",
        calculateScore: function(metric) {
          if (!metric.calced) return null;
          
          // this would go from about -200 to 200, if head in center (and screen is 400 tall),
          // < -100 is score 0, > 100 is score 1, and in between is linear.
          return Math.min(1, Math.max(0, (metric.twoD + 100) / 200));
        }
      },
      leftHandBack: {
        title: "Left Hand Back",
        calculateScore: function(metric) {
          if (!metric.calced) return null;
          
          // Orientation range is approximately -1 to 1
          // Negative: palm facing camera (score 0)
          // Positive: back of hand facing camera (score 1)
          if (metric.orientation >= 0.7) {
            return 1;
          } else if (metric.orientation <= 0) {
            return 0;
          } else {
            return metric.orientation / 0.7;
          }
        }
      },
      rightHandBack: {
        title: "Right Hand Back",
        calculateScore: function(metric) {
          if (!metric.calced) return null;
          
          // Orientation range is approximately -1 to 1
          // Negative: palm facing camera (score 0)
          // Positive: back of hand facing camera (score 1)
          if (metric.orientation >= 0.7) {
            return 1;
          } else if (metric.orientation <= 0) {
            return 0;
          } else {
            return metric.orientation / 0.7;
          }
        }
      }
    };

    let gameState = {
      started: false,
      playing: false,
      level: 1,
      ended: false,
      countdown: false,
      countdownStartTime: 0,
      levelStartTime: 0,
      scores: {},
      totalScore: 0,
      progressHistory: [], // Array to store recent progress values
      progressHistorySize: 5, // Number of frames to average
      mode: null, // 'standard' or 'endless'
      menuScreen: true, // Show mode selection menu
      endlessLevels: [], // All possible combinations for endless mode
      usedEndlessLevelIndices: [] // Track which levels have been used
    };

    // Standard mode levels
    let levels = [
      {
        progressFunction: (metrics) => {
          // Level 1: Raise hands above head
          return metrics.handsOverHead.score;
        },
      },
      {
        progressFunction: (metrics) => {
          // Level 2: Pinch left thumb and index finger
          return metrics.leftHandPinch.score;
        },
      },
      {
        progressFunction: (metrics) => {
          // Level 3: Open mouth and bring wrists together
          if (metrics.mouthOpen.score == null || metrics.wrists.score == null) {
            return null;
          }
          
          // Half the score is mouth open, half is wrists
          return (metrics.mouthOpen.score + metrics.wrists.score) / 2;
        },
      },
      {
        progressFunction: (metrics) => {
          // Level 4: Show the back of both hands to the camera (50% weight for each hand)
          if (metrics.leftHandBack.score == null || metrics.rightHandBack.score == null) {
            return null;
          }
          
          // Return average of both hand scores (50% weight each)
          return (metrics.leftHandBack.score + metrics.rightHandBack.score) / 2;
        },
      }
    ]
    
    // Available metrics for endless mode
    const availableMetrics = [
      { 
        id: 'handsOverHead',
        title: 'Raise hands above head'
      },
      { 
        id: 'leftHandPinch',
        title: 'Pinch left thumb and index finger'
      },
      { 
        id: 'rightHandPinch',
        title: 'Pinch right thumb and index finger'
      },
      { 
        id: 'mouthOpen',
        title: 'Open mouth'
      },
      { 
        id: 'wrists',
        title: 'Bring wrists together'
      },
      { 
        id: 'leftHandBack',
        title: 'Show back of left hand'
      },
      { 
        id: 'rightHandBack',
        title: 'Show back of right hand'
      }
    ];
    
    // Generate all possible metric combinations for endless mode
    function generateAllEndlessLevels() {
      const allLevels = [];
      
      // First, add all single-metric levels
      for (let i = 0; i < availableMetrics.length; i++) {
        const metric = availableMetrics[i];
        allLevels.push({
          metricIds: [metric.id],
          progressFunction: (metrics) => {
            return metrics[metric.id].score;
          }
        });
      }
      
      // Then, add all possible combinations of two metrics
      for (let i = 0; i < availableMetrics.length; i++) {
        for (let j = i + 1; j < availableMetrics.length; j++) {
          const metric1 = availableMetrics[i];
          const metric2 = availableMetrics[j];
          
          allLevels.push({
            metricIds: [metric1.id, metric2.id],
            progressFunction: (metrics) => {
              if (metrics[metric1.id].score == null || metrics[metric2.id].score == null) {
                return null;
              }
              
              // Average of both scores (50% weight each)
              return (metrics[metric1.id].score + metrics[metric2.id].score) / 2;
            }
          });
        }
      }
      
      return allLevels;
    }
    
    // Get next endless level based on game state
    function getNextEndlessLevel() {
      // If there are no endless levels generated yet, create them
      if (gameState.endlessLevels.length === 0) {
        gameState.endlessLevels = generateAllEndlessLevels();
      }
      
      let levelIndex;
      
      if (gameState.level <= 3) {
        // First three levels should be single metrics
        const unusedSingleLevels = gameState.endlessLevels
          .map((level, index) => ({ level, index }))
          .filter(item => item.level.metricIds.length === 1)
          .filter(item => !gameState.usedEndlessLevelIndices.includes(item.index));
        
        if (unusedSingleLevels.length === 0) {
          // This shouldn't happen in the first 3 rounds, but just in case
          return null;
        }
        
        const randomIndex = Math.floor(Math.random() * unusedSingleLevels.length);
        levelIndex = unusedSingleLevels[randomIndex].index;
      } else {
        // After round 3, use any remaining single metrics or double combinations
        const unusedLevels = gameState.endlessLevels
          .map((level, index) => ({ level, index }))
          .filter(item => !gameState.usedEndlessLevelIndices.includes(item.index));
        
        if (unusedLevels.length === 0) {
          // All levels have been used, end the game
          return null;
        }
        
        const randomIndex = Math.floor(Math.random() * unusedLevels.length);
        levelIndex = unusedLevels[randomIndex].index;
      }
      
      // Mark this level as used
      gameState.usedEndlessLevelIndices.push(levelIndex);
      
      return gameState.endlessLevels[levelIndex];
    }

    function preload() {
      // TODO at least faceMesh has a maxFaces option, which would be nice to use
      // (and show error message around??)
      handPose = ml5.handPose({ flipped: true });
      bodyPose = ml5.bodyPose("BlazePose", { flipped: true });
      faceMesh = ml5.faceMesh({ flipped: true, refineLandmarks: true });
    }

    function setup() {
      createCanvas(640, 480);

      // Create video and hide it
      video = createCapture(VIDEO, { flipped: true });
      video.size(640, 480);
      video.hide();

      handPose.detectStart(video, gotHands);
      bodyPose.detectStart(video, gotBodies);
      faceMesh.detectStart(video, gotFaces);

      // Set text to bold by default
      textStyle(BOLD);
      
      resetGame();
    }

    function gotHands(results) {
      hands = results;
    }

    function gotBodies(results) {
      bodies = results;
    }

    function gotFaces(results) {
      faces = results;
    }

    function computeMetrics() {
      // Create metrics instance, initializing with titles and calced=false
      const metrics = {};
      for (const key in metricsDefinition) {
        metrics[key] = {
          title: metricsDefinition[key].title,
          calced: false
        };
      }

      if (hands) {
        for (let i = 0; i < hands.length; i++) {
          const hand = hands[i];
          const thumbTip = hand?.thumb_tip;
          const indexTip = hand?.index_finger_tip;
          
          // We need these points for hand orientation calculation
          const wrist = hand?.wrist;
          const middleBase = hand?.middle_finger_mcp; // Middle finger metacarpophalangeal joint (base)
          const indexBase = hand?.index_finger_mcp;   // Index finger base
          const pinkyBase = hand?.pinky_finger_mcp;   // Pinky finger base

          if (hand.confidence > 0.9 && thumbTip && indexTip) {
            if (hand.handedness === "Left") {
              metrics.leftHandPinch.calced = true;
              metrics.leftHandPinch.twoD = calculate2DDistance(thumbTip, indexTip);
              metrics.leftHandPinch.threeD = calculateHand3DDistance(thumbTip, indexTip);
            } else if (hand.handedness === "Right") {
              metrics.rightHandPinch.calced = true;
              metrics.rightHandPinch.twoD = calculate2DDistance(thumbTip, indexTip);
              metrics.rightHandPinch.threeD = calculateHand3DDistance(thumbTip, indexTip);
            }
          }
          
          // Calculate hand back metrics when all required points are available
          if (hand.confidence > 0.9 && wrist && middleBase && indexBase && pinkyBase) {
            // Calculate a vector normal to the palm plane using cross product
            // First we create vectors along the palm
            const v1 = {
              x: indexBase.x3D - wrist.x3D,
              y: indexBase.y3D - wrist.y3D,
              z: indexBase.z3D - wrist.z3D
            };
            
            const v2 = {
              x: pinkyBase.x3D - wrist.x3D,
              y: pinkyBase.y3D - wrist.y3D,
              z: pinkyBase.z3D - wrist.z3D
            };

            
            // Cross product gives normal vector to palm
            const normal = {
              x: v1.y * v2.z - v1.z * v2.y,
              y: v1.z * v2.x - v1.x * v2.z,
              z: v1.x * v2.y - v1.y * v2.x
            };
            
            // Normalize the vector (z component is what we care about)
            const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
            normal.z = normal.z / length;
            
            // The normal.z value indicates palm orientation:
            // Positive: palm facing camera
            // Negative: back of hand facing camera
            // Range is roughly -1 to 1
            
            if (hand.handedness === "Left") {
              metrics.leftHandBack.calced = true;
              metrics.leftHandBack.orientation = normal.z;
            } else if (hand.handedness === "Right") {
              metrics.rightHandBack.calced = true;
              // Invert so positive means back of hand to camera
              metrics.rightHandBack.orientation = - normal.z;
            }
          }
        }
      }

      if (bodies && bodies.length > 0) {
        const body = bodies[0];
        const leftWrist = body?.left_wrist;
        const rightWrist = body?.right_wrist;

        if ((leftWrist && leftWrist.confidence > 0.5) && (rightWrist && rightWrist.confidence > 0.5)) {
          metrics.wrists.calced = true;
          metrics.wrists.twoD = calculate2DDistance(leftWrist, rightWrist);
          metrics.wrists.threeD = calculateBody3DDistance(leftWrist, rightWrist);
        }

        const nose = body?.nose;

        if ((nose && nose.confidence > 0.9) && (leftWrist && leftWrist.confidence > 0.9) && (rightWrist && rightWrist.confidence > 0.9)) {
          metrics.handsOverHead.calced = true;

          // this one is easiest as just 2d height on screen
          const averageWristHeight = (leftWrist.y + rightWrist.y) / 2;
          metrics.handsOverHead.twoD = nose.y - averageWristHeight;
        }

      }

      if (faces && faces.length > 0) {
        const face = faces[0];
        // if (Math.random() < 0.1) {
        //   console.log(face);
        // }
        // console.log(face);

        // it's a little tricky to get a 3d distance for the face,
        // because the points are always given x/y/z which I'm not really sure how to make sense of.
        // but the effect is that using the 3d distance seems to scale when I approach camera,
        // which is not what I want. instead, I'll use the ratio of height of lips to width of lips
        // to get a sense of open/closed.
        if (face.lips) {
          metrics.mouthOpen.calced = true;
          metrics.mouthOpen.ratio = face.lips?.height / face.lips?.width * 100.;
        }

        // TODO note this doesn't really work yet. rotating the head screws it up dramatically,
        // which I think is because x / y are projections onto the screen (how we're seeing them...)
        // I think I need to read more about how to project them into space.
        // mouth seems to have this issue to a much lesser degree.
        if (face.leftEye && face.rightEye) {
          // yipes. these are using indexes from: https://github.com/lschmelzeisen/understanding-mediapipe-facemesh-output/tree/main
          const rightEyeInsideCorner = face.keypoints[133];
          const rightEyeOutsideCorner = face.keypoints[33];
          const rightEye = calculateFaceAveragePoint(rightEyeInsideCorner, rightEyeOutsideCorner);
          const rightEyebrowMidInside = face.keypoints[65];
          const rightEyebrowMidOutside = face.keypoints[52];
          const rightEyebrow = calculateFaceAveragePoint(rightEyebrowMidInside, rightEyebrowMidOutside);
          const rightEyebrowDist = calculateFace3DDistance(rightEyebrowMidInside, rightEyebrowMidOutside);

          const leftEyeInsideCorner = face.keypoints[362];
          const leftEyeOutsideCorner = face.keypoints[263];
          const leftEye = calculateFaceAveragePoint(leftEyeInsideCorner, leftEyeOutsideCorner);
          const leftEyebrowMidInside = face.keypoints[295];
          const leftEyebrowMidOutside = face.keypoints[282];
          const leftEyebrow = calculateFaceAveragePoint(leftEyebrowMidInside, leftEyebrowMidOutside);
          const leftEyebrowDist = calculateFace3DDistance(leftEyebrowMidInside, leftEyebrowMidOutside);

          // console.log({rightEyebrowDist, leftEyebrowDist});

          metrics.eyebrowRaised.ratio = leftEyebrowDist / rightEyebrowDist * 100;
          metrics.eyebrowRaised.calced = true;
        }
      }
      
      // Calculate scores for all metrics
      for (const key in metrics) {
        if (metrics[key].calced) {
          metrics[key].score = metricsDefinition[key].calculateScore(metrics[key]);
        } else {
          metrics[key].score = null;
        }
      }

      return metrics;
    }

    function drawAllPoints() {
      if (hands) {
        for (let i = 0; i < hands.length; i++) {
          const hand = hands[i];
          drawKeypoints(hand);
          drawHandSkeleton(hand);
        }
      }
      if (bodies) {
        for (let i = 0; i < bodies.length; i++) {
          const body = bodies[i];
          drawKeypoints(body);
        }
      }
      if (faces) {
        for (let i = 0; i < faces.length; i++) {
          const face = faces[i];
          // drawKeypoints(face.lips);
          // drawKeypoints(face.leftEye);
          // drawKeypoints(face.leftEyebrow);
        }
      }
    }

    function drawAllMetrics(metrics) {
      const metricStrs = [];
      for (const key in metrics) {
        const metric = metrics[key];
        if (metric.calced) {
          metricStr = "";
          if (metric.twoD != null) {
            metricStr += "2D: " + Math.round(metric.twoD) + "; ";
          }
          if (metric.threeD != null) {
            metricStr += "3D: " + Math.round(metric.threeD) + "; ";
          }
          if (metric.ratio != null) {
            metricStr += "Ratio: " + Math.round(metric.ratio) + "; ";
          }
          if (metric.orientation != null) {
            metricStr += "Orient: " + metric.orientation.toFixed(2) + "; ";
          }
          if (metric.score != null) {
            metricStr += "Score: " + metric.score.toFixed(2);
          }
          metricStrs.push(metric.title + ": " + metricStr);
        } else {
          metricStrs.push(metric.title + ": Not available");
        }
      }

      drawDistanceBox(metricStrs);
    }

    function draw() {
      image(video, 0, 0, width, height);

      const metrics = computeMetrics();

      // Only show debugging info if debug mode is enabled
      if (debugMode) {
        drawAllMetrics(metrics);
        drawAllPoints();
      }

      // Reset text style to bold for game UI after potential debug drawing
      textStyle(BOLD);
      
      // Add overlay for text readability when needed
      if (!gameState.playing) {
        // Simple semi-transparent dark overlay
        fill(0, 0, 0, 150);
        noStroke();
        rect(0, 0, width, height);
      }

      // console.log(gameState)

      // show game state
      if (!gameState.started) {
        if (gameState.menuScreen) {
          // Mode selection screen
          push();
          fill(255);
          textSize(42);
          textAlign(CENTER, CENTER);
          text("PROPRIOCEPTION", width / 2, height / 2 - 80);
          
          // Draw mode selection buttons
          const buttonWidth = 160;
          const buttonHeight = 50;
          const buttonSpacing = 20;
          const buttonY = height / 2 + 20;
          
          // Standard mode button
          const standardX = width / 2 - buttonWidth - buttonSpacing/2;
          fill(80, 80, 80);
          stroke(255);
          strokeWeight(2);
          rect(standardX, buttonY, buttonWidth, buttonHeight, 8);
          
          // Endless mode button
          const endlessX = width / 2 + buttonSpacing/2;
          fill(80, 80, 80);
          stroke(255);
          strokeWeight(2);
          rect(endlessX, buttonY, buttonWidth, buttonHeight, 8);
          
          // Button text
          noStroke();
          fill(255);
          textSize(20);
          textAlign(CENTER, CENTER);
          text("STANDARD", standardX + buttonWidth/2, buttonY + buttonHeight/2);
          text("ENDLESS", endlessX + buttonWidth/2, buttonY + buttonHeight/2);
          
          // Instructions
          textSize(16);
          fill(200, 200, 200);
          text("Click to select game mode", width / 2, buttonY + buttonHeight + 30);
          pop();
          
          // Check for button clicks
          if (mouseIsPressed) {
            if (mouseX > standardX && mouseX < standardX + buttonWidth &&
                mouseY > buttonY && mouseY < buttonY + buttonHeight) {
              // Standard mode selected
              startGame('standard');
              startCountdown();
            } else if (mouseX > endlessX && mouseX < endlessX + buttonWidth &&
                     mouseY > buttonY && mouseY < buttonY + buttonHeight) {
              // Endless mode selected
              startGame('endless');
              startCountdown();
            }
          }
        } else {
          // Title and start screen - more understated
          push();
          fill(255);
          textSize(42);
          textAlign(CENTER, CENTER);
          text("PROPRIOCEPTION", width / 2, height / 2 - 30);
          
          // Instructions - simple white text
          textSize(24);
          text("Press any key to start", width / 2, height / 2 + 40);
          
          // Debug info - smaller and less obtrusive
          // textSize(14);
          // fill(180, 180, 180);
          // text("Press 'D' to toggle debug view", width / 2, height - 20);
          pop();
        }
      } else if (gameState.ended) {
        // Game over screen - more understated
        push();
        fill(255);
        textSize(28);
        textAlign(CENTER, CENTER);
        text("Game Complete", width / 2, height / 2 - 80);
        
        // Display scores in a clean, minimal format
        noStroke();
        
        textSize(20);
        textAlign(RIGHT, CENTER);
        text("LEVEL", width/2 - 100, height/2 - 40);
        text("TIME", width/2 + 100, height/2 - 40);
        
        // Display scores for each level
        fill(255);
        textSize(18);
        let scoreY = height / 2;
        
        for (let level in gameState.scores) {
          textAlign(RIGHT, CENTER);
          text(level, width/2 - 100, scoreY);
          textAlign(LEFT, CENTER);
          text(gameState.scores[level] + " sec.", width/2 + 20, scoreY);
          scoreY += 26;
        }
        
        // Display total score - aligned with level scores
        fill(255);
        textSize(18);
        textAlign(RIGHT, CENTER);
        text("TOTAL", width/2 - 100, scoreY);
        textAlign(LEFT, CENTER);
        text(gameState.totalScore + " sec.", width/2 + 20, scoreY);
        
        // Add instruction to press key to restart (positioned at fixed distance from bottom)
        textSize(18);
        text("Press any key to play again", width / 2, height - 40);
        pop();
      } else if (gameState.countdown) {
        // Handle countdown
        const elapsedTime = millis() - gameState.countdownStartTime;
        const countdownSeconds = 3 - Math.floor(elapsedTime / 1000);
        
        if (countdownSeconds <= 0) {
          // Countdown finished, start level
          gameState.countdown = false;
          startLevel();
        } else {
          push();
          // Level title - simple, clean
          fill(255);
          textSize(24);
          textAlign(CENTER, CENTER);
          
          // Just show the level number, no titles
          text("Level " + gameState.level, width / 2, height / 2 - 40);
          
          // Make sure we have a current endless level if needed
          if (gameState.mode === 'endless' && !currentEndlessLevel && gameState.level === 1) {
            currentEndlessLevel = getNextEndlessLevel();
          }
          
          // Countdown number - simple, no effects
          textSize(60);
          text(countdownSeconds, width / 2, height / 2 + 20);
          pop();
        }
      } else {
        // Get the current level and progress function based on mode
        let progressFunction;
        let rawProgress;
        
        if (gameState.mode === 'standard') {
          // Standard mode - get level from predefined array
          const levelIndex = gameState.level - 1;
          const level = levels[levelIndex];
          progressFunction = level.progressFunction;
        } else if (gameState.mode === 'endless') {
          // Endless mode - use current endless level
          progressFunction = currentEndlessLevel.progressFunction;
        }
        
        // Calculate progress
        rawProgress = progressFunction(metrics);
        
        // Apply smoothing to progress value
        const smoothedProgress = smoothProgress(rawProgress);
        const progress = smoothedProgress;
        
        if (progress >= 1) {
          nextLevel();
          return;
        }
        // Display level and current time - minimal design
        const currentTime = ((millis() - gameState.levelStartTime) / 1000).toFixed(1);
        
        // Simple text without box
        push();
        fill(255);
        textSize(20);
        textAlign(LEFT, TOP);
        text("Level " + gameState.level + " • " + currentTime + "s", 20, 20);
        pop();
        
        if (progress != null) {
          // Show progress bar
          textSize(32);
          textAlign(CENTER, CENTER);
          drawProgressBar(progress);
        } else {
          fill(255);
          textSize(32);
          textAlign(CENTER, CENTER);
          text("Relevant body parts not detected", width / 2, height / 2);
        }
      }
    }

    // Removed overlay functions to fix visual issues
    
    function drawProgressBar(progress) {
      const barWidth = 300;
      const barHeight = 8;
      const barX = (width - barWidth) / 2;
      const barY = height - 40;

      // Draw background
      push();
      noStroke();
      fill(255, 255, 255, 40);
      rect(barX, barY, barWidth, barHeight, 4);

      // Draw the progress bar - simple, modern
      fill(255);
      rect(barX, barY, barWidth * progress, barHeight, 4);
      pop();
    }

    function drawKeypoints(obj) {
      for (let j = 0; j < obj.keypoints.length; j++) {
        let keypoint = obj.keypoints[j];
        if (keypoint.confidence < 0.9) {
          continue;
        }
        fill(0, 255, 0);
        noStroke();
        circle(keypoint.x, keypoint.y, 10);
      }
    }
    function calculate2DDistance(point1, point2) {
      const dx = point1.x - point2.x;
      const dy = point1.y - point2.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function calculateHand3DDistance(point1, point2) {
      const dx = point1.x3D - point2.x3D;
      const dy = point1.y3D - point2.y3D;
      const dz = point1.z3D - point2.z3D;
      return Math.sqrt(dx * dx + dy * dy + dz * dz) * 100.;
    }

    function calculateBody3DDistance(point1, point2) {
      const dx = point1.keypoint3D.x - point2.keypoint3D.x;
      const dy = point1.keypoint3D.y - point2.keypoint3D.y;
      const dz = point1.keypoint3D.z - point2.keypoint3D.z;
      return Math.sqrt(dx * dx + dy * dy + dz * dz) * 100.;
    }

    function calculateFace3DDistance(point1, point2) {
      // I think this is a little funny, or at least maybe should only be used for ratios.
      // not sure how to interpret z.
      const dx = point1.x - point2.x;
      const dy = point1.y - point2.y;
      const dz = point1.z - point2.z;
      return Math.sqrt(dx * dx + dy * dy + dz * dz) * 100.;
    }

    function calculateFaceAveragePoint(point1, point2) {
      const x = (point1.x + point2.x) / 2;
      const y = (point1.y + point2.y) / 2;
      const z = (point1.z + point2.z) / 2;
      return { x, y, z };
    }

    // function calculateFace3DDistance(point1, point2) {
    //   const dx = point1.x - point2.x;
    //   const dy = point1.y - point2.y;
    //   const dz = point1.z - point2.z;
    //   return Math.sqrt(dx * dx + dy * dy + dz * dz) * 100.;
    // }

    function drawDistanceBox(distanceStrs) {
      // Box parameters
      const padding = 10;
      const lineHeight = 16; // Smaller line height for smaller text
      const boxWidth = 300;
      const boxHeight = padding * 2 + lineHeight * distanceStrs.length;
      const boxX = 20;
      const boxY = 20;

      // Draw box with semi-transparent background
      push();
      fill(0, 0, 0, 230);    // More opaque background
      stroke(255, 255, 0);   // Yellow border
      strokeWeight(3);       // Thicker border
      rect(boxX, boxY, boxWidth, boxHeight, 10);  // Rounded corners

      // Draw text - not bold and smaller
      fill(255);             // White text
      noStroke();
      textStyle(NORMAL);     // Non-bold text for metrics
      textSize(14);          // Smaller text size
      textAlign(LEFT, TOP);

      // Show each distance string
      for (let i = 0; i < distanceStrs.length; i++) {
        text(distanceStrs[i], boxX + padding, boxY + padding + i * lineHeight);
      }
      pop();
    }

    function drawHandSkeleton(hand) {
      // Define finger connections
      const fingerConnections = [
        // Thumb [connections]
        [0, 1, 2, 3, 4],
        // Index finger 
        [0, 5, 6, 7, 8],
        // Middle finger
        [0, 9, 10, 11, 12],
        // Ring finger
        [0, 13, 14, 15, 16],
        // Pinky
        [0, 17, 18, 19, 20]
      ];

      // Define colors for each finger
      const colors = [
        [255, 0, 0],      // thumb (red)
        [0, 255, 0],      // index (green)
        [0, 0, 255],      // middle (blue)
        [255, 255, 0],    // ring (yellow)
        [255, 0, 255]     // pinky (magenta)
      ];

      // Draw each finger
      for (let i = 0; i < fingerConnections.length; i++) {
        const points = fingerConnections[i];
        const color = colors[i];

        stroke(color[0], color[1], color[2]);
        strokeWeight(2);

        // Draw lines connecting each point in the finger
        for (let j = 0; j < points.length - 1; j++) {
          const keypoint1 = hand.keypoints[points[j]];
          const keypoint2 = hand.keypoints[points[j + 1]];

          if (keypoint1 && keypoint2) {
            line(keypoint1.x, keypoint1.y, keypoint2.x, keypoint2.y);
          }
        }
      }
    }

    function smoothProgress(rawProgress) {
      // Handle null value
      if (rawProgress === null) {
        gameState.progressHistory = []; // Clear history when detection is lost
        return null;
      }
      
      // Add current value to history
      gameState.progressHistory.push(rawProgress);
      
      // Limit history size
      if (gameState.progressHistory.length > gameState.progressHistorySize) {
        gameState.progressHistory.shift(); // Remove oldest value
      }
      
      // Calculate weighted average (more recent values have more weight)
      let totalWeight = 0;
      let weightedSum = 0;
      
      for (let i = 0; i < gameState.progressHistory.length; i++) {
        // Weight increases with index (newer values get higher weights)
        const weight = i + 1;
        weightedSum += gameState.progressHistory[i] * weight;
        totalWeight += weight;
      }
      
      return weightedSum / totalWeight;
    }
    
    // Current endless mode level (for reference)
    let currentEndlessLevel = null;
    
    function resetGame() {
      gameState.started = false;
      gameState.level = 1;
      gameState.ended = false;
      gameState.countdown = false;
      gameState.playing = false;
      gameState.scores = {};
      gameState.totalScore = 0;
      gameState.progressHistory = [];
      gameState.menuScreen = true;
      gameState.mode = null;
      gameState.endlessLevels = [];
      gameState.usedEndlessLevelIndices = [];
      currentEndlessLevel = null;
    }

    function startGame(mode) {
      gameState.started = true;
      gameState.menuScreen = false;
      gameState.mode = mode;
      
      // For endless mode, generate all levels if not already done
      if (mode === 'endless' && gameState.endlessLevels.length === 0) {
        gameState.endlessLevels = generateAllEndlessLevels();
      }
    }

    function endGame() {
      // Calculate score for final level
      const levelTime = (millis() - gameState.levelStartTime) / 1000;
      gameState.scores[gameState.level] = levelTime.toFixed(2);
      gameState.totalScore += parseFloat(levelTime);
      gameState.totalScore = gameState.totalScore.toFixed(2); // Format total to 2 decimal places
      
      gameState.playing = false; // Make sure playing is set to false
      gameState.ended = true;
    }

    function startLevel() {
      gameState.playing = true;
      gameState.levelStartTime = millis();
      gameState.progressHistory = []; // Reset progress history for new level
    }

    function startCountdown() {
      gameState.countdown = true;
      gameState.countdownStartTime = millis();
    }

    function nextLevel() {
      // Calculate and store score for the completed level
      const levelTime = (millis() - gameState.levelStartTime) / 1000; // Convert to seconds
      gameState.scores[gameState.level] = levelTime.toFixed(2);
      gameState.totalScore += parseFloat(levelTime);
      
      // Move to next level
      gameState.level++;
      gameState.playing = false;
      
      if (gameState.mode === 'endless') {
        // Get the next endless level
        currentEndlessLevel = getNextEndlessLevel();
        
        // If there are no more levels, end the game
        if (currentEndlessLevel === null) {
          endGame();
          return;
        }
      } else if (gameState.mode === 'standard') {
        // End the game if we've completed all standard levels
        if (gameState.level > levels.length) {
          endGame();
          return;
        }
      }
      
      startCountdown();
    }

    function restartGame() {
      resetGame();
      // Go back to the menu screen
    }
    
    function keyPressed() {
      // Toggle debug mode with 'd' key regardless of game state
      if (key === 'd' || key === 'D') {
        debugMode = !debugMode;
        return;
      }
      
      // Handle restart after game over
      if (gameState.ended) {
        restartGame();
        return;
      }
      
      // Don't proceed if already playing or counting down
      if (gameState.playing || gameState.countdown) {
        return;
      }
      
      // Starting a new game or level
      if (!gameState.started && !gameState.menuScreen) {
        // Only start with key press if we're not on the menu screen
        startGame(gameState.mode || 'standard');
        startCountdown();
      } else if (gameState.started) {
        startCountdown();
      }
      // Note: on menu screen, clicks handle mode selection, not key presses
    }
  </script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ML5.js Handpose</title>
  <script src="./p5@1.11.1.min.js"></script>
  <script src="./ml5@1.2.1.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <script>
    let video;
    let handPose;
    let bodyPose;
    let faceMesh;
    let hands;
    let bodies;
    let faces;

    let gameState = {
      started: false,
      playing: false,
      level: 1,
      ended: false,
      countdown: false,
      countdownStartTime: 0,
    };

    let levels = {
      1: {
        progressFunction: (metrics) => {
          if (!metrics.handsOverHead.calced) {
            return null;
          }
          // this would go from about -200 to 200, if head in center (and screen is 400 tall),
          // so let's say < -100 is 0, > 100 is 1, and in between is linear.
          const progress = Math.min(1, Math.max(0, (metrics.handsOverHead.twoD + 100) / 200));
          return progress;
        },
      },
      2: {
        progressFunction: (metrics) => {
          if (!metrics.leftHandPinch.calced) {
            return null;
          }

          // range is about 1 - 15.
          // want to say < 4 is 1, > 10 is 0, and in between is linear.
          if (metrics.leftHandPinch.threeD <= 4) {
            return 1;
          } else if (metrics.leftHandPinch.threeD > 10) {
            return 0;
          } else {
            return 1 - (metrics.leftHandPinch.threeD - 4) / 6;
          }
        },
      },
      3: {
        progressFunction: (metrics) => {
          if (!metrics.mouthOpen.calced || !metrics.wrists.calced) {
            return null;
          }

          // half the score is mouth open, half is wrists.

          // mouth open is around 20 - 120, so let's say < 30 is 0, > 100 is 1, and in between is linear.
          const mouthProgress = Math.min(1, Math.max(0, (metrics.mouthOpen.ratio - 30) / 70));

          // wrists are 10 - 70, so let's say < 20 is 0, > 60 is 1, and in between is linear.
          const wristProgress = Math.min(1, Math.max(0, 1 - (metrics.wrists.threeD - 20) / 40));

          return (mouthProgress + wristProgress) / 2;
        },
      }
    }

    function preload() {
      // TODO at least faceMesh has a maxFaces option, which would be nice to use
      // (and show error message around??)
      handPose = ml5.handPose({ flipped: true });
      bodyPose = ml5.bodyPose("BlazePose", { flipped: true });
      faceMesh = ml5.faceMesh({ flipped: true, refineLandmarks: true });
    }

    function setup() {
      createCanvas(640, 480);

      // Create video and hide it
      video = createCapture(VIDEO, { flipped: true });
      video.size(640, 480);
      video.hide();

      handPose.detectStart(video, gotHands);
      bodyPose.detectStart(video, gotBodies);
      faceMesh.detectStart(video, gotFaces);

      resetGame();
    }

    function gotHands(results) {
      hands = results;
    }

    function gotBodies(results) {
      bodies = results;
    }

    function gotFaces(results) {
      faces = results;
    }

    function computeMetrics() {
      const metrics = {
        leftHandPinch: {
          title: "Left Hand Pinch",
          calced: false,
        },
        rightHandPinch: {
          title: "Right Hand Pinch",
          calced: false,
        },
        wrists: {
          title: "Wrists",
          calced: false
        },
        mouthOpen: {
          title: "Mouth Open",
          calced: false
        },
        eyebrowRaised: {
          title: "Eyebrow Raised",
          calced: false
        },
        handsOverHead: {
          title: "Hands Over Head",
          calced: false
        },
      };

      if (hands) {
        for (let i = 0; i < hands.length; i++) {
          const hand = hands[i];
          const thumbTip = hand?.thumb_tip;
          const indexTip = hand?.index_finger_tip;

          if (hand.confidence > 0.9 && thumbTip && indexTip) {
            if (hand.handedness === "Left") {
              metrics.leftHandPinch.calced = true;
              metrics.leftHandPinch.twoD = calculate2DDistance(thumbTip, indexTip);
              metrics.leftHandPinch.threeD = calculateHand3DDistance(thumbTip, indexTip);
            } else if (hand.handedness === "Right") {
              metrics.rightHandPinch.calced = true;
              metrics.rightHandPinch.twoD = calculate2DDistance(thumbTip, indexTip);
              metrics.rightHandPinch.threeD = calculateHand3DDistance(thumbTip, indexTip);
            }
          }
        }
      }

      if (bodies && bodies.length > 0) {
        const body = bodies[0];
        const leftWrist = body?.left_wrist;
        const rightWrist = body?.right_wrist;

        if ((leftWrist && leftWrist.confidence > 0.5) && (rightWrist && rightWrist.confidence > 0.5)) {
          metrics.wrists.calced = true;
          metrics.wrists.twoD = calculate2DDistance(leftWrist, rightWrist);
          metrics.wrists.threeD = calculateBody3DDistance(leftWrist, rightWrist);
        }

        const nose = body?.nose;

        if ((nose && nose.confidence > 0.9) && (leftWrist && leftWrist.confidence > 0.9) && (rightWrist && rightWrist.confidence > 0.9)) {
          metrics.handsOverHead.calced = true;

          // this one is easiest as just 2d height on screen
          const averageWristHeight = (leftWrist.y + rightWrist.y) / 2;
          metrics.handsOverHead.twoD = nose.y - averageWristHeight;
        }

      }

      if (faces && faces.length > 0) {
        const face = faces[0];
        // if (Math.random() < 0.1) {
        //   console.log(face);
        // }
        // console.log(face);

        // it's a little tricky to get a 3d distance for the face,
        // because the points are always given x/y/z which I'm not really sure how to make sense of.
        // but the effect is that using the 3d distance seems to scale when I approach camera,
        // which is not what I want. instead, I'll use the ratio of height of lips to width of lips
        // to get a sense of open/closed.
        if (face.lips) {
          metrics.mouthOpen.calced = true;
          metrics.mouthOpen.ratio = face.lips?.height / face.lips?.width * 100.;
        }

        // TODO note this doesn't really work yet. rotating the head screws it up dramatically,
        // which I think is because x / y are projections onto the screen (how we're seeing them...)
        // I think I need to read more about how to project them into space.
        // mouth seems to have this issue to a much lesser degree.
        if (face.leftEye && face.rightEye) {
          // yipes. these are using indexes from: https://github.com/lschmelzeisen/understanding-mediapipe-facemesh-output/tree/main
          const rightEyeInsideCorner = face.keypoints[133];
          const rightEyeOutsideCorner = face.keypoints[33];
          const rightEye = calculateFaceAveragePoint(rightEyeInsideCorner, rightEyeOutsideCorner);
          const rightEyebrowMidInside = face.keypoints[65];
          const rightEyebrowMidOutside = face.keypoints[52];
          const rightEyebrow = calculateFaceAveragePoint(rightEyebrowMidInside, rightEyebrowMidOutside);
          const rightEyebrowDist = calculateFace3DDistance(rightEyebrowMidInside, rightEyebrowMidOutside);

          const leftEyeInsideCorner = face.keypoints[362];
          const leftEyeOutsideCorner = face.keypoints[263];
          const leftEye = calculateFaceAveragePoint(leftEyeInsideCorner, leftEyeOutsideCorner);
          const leftEyebrowMidInside = face.keypoints[295];
          const leftEyebrowMidOutside = face.keypoints[282];
          const leftEyebrow = calculateFaceAveragePoint(leftEyebrowMidInside, leftEyebrowMidOutside);
          const leftEyebrowDist = calculateFace3DDistance(leftEyebrowMidInside, leftEyebrowMidOutside);

          // console.log({rightEyebrowDist, leftEyebrowDist});

          metrics.eyebrowRaised.ratio = leftEyebrowDist / rightEyebrowDist * 100;
          metrics.eyebrowRaised.calced = true;
        }
      }

      return metrics;
    }

    function drawAllPoints() {
      if (hands) {
        for (let i = 0; i < hands.length; i++) {
          const hand = hands[i];
          drawKeypoints(hand);
          drawHandSkeleton(hand);
        }
      }
      if (bodies) {
        for (let i = 0; i < bodies.length; i++) {
          const body = bodies[i];
          drawKeypoints(body);
        }
      }
      if (faces) {
        for (let i = 0; i < faces.length; i++) {
          const face = faces[i];
          // drawKeypoints(face.lips);
          // drawKeypoints(face.leftEye);
          // drawKeypoints(face.leftEyebrow);
        }
      }
    }

    function drawAllMetrics(metrics) {
      const metricStrs = [];
      for (const key in metrics) {
        const metric = metrics[key];
        if (metric.calced) {
          metricStr = "";
          if (metric.twoD) {
            metricStr += "2D: " + Math.round(metric.twoD) + "; ";
          }
          if (metric.threeD) {
            metricStr += "3D: " + Math.round(metric.threeD);
          }
          if (metric.ratio) {
            metricStr += "Ratio: " + Math.round(metric.ratio);
          }
          metricStrs.push(metric.title + ": " + metricStr);
        } else {
          metricStrs.push(metric.title + ": Not available");
        }
      }

      drawDistanceBox(metricStrs);
    }

    function draw() {
      image(video, 0, 0, width, height);

      const metrics = computeMetrics();

      // debugging
      drawAllMetrics(metrics);
      drawAllPoints();

      // console.log(gameState)

      // show game state
      if (!gameState.started) {
        fill(255);
        textSize(32);
        textAlign(CENTER, CENTER);
        text("Press any key to start new game", width / 2, height / 2);
      } else if (gameState.ended) {
        fill(255);
        textSize(32);
        textAlign(CENTER, CENTER);
        text("Game Over", width / 2, height / 2);
      } else if (gameState.countdown) {
        // Handle countdown
        const elapsedTime = millis() - gameState.countdownStartTime;
        const countdownSeconds = 3 - Math.floor(elapsedTime / 1000);
        
        if (countdownSeconds <= 0) {
          // Countdown finished, start level
          gameState.countdown = false;
          startLevel();
        } else {
          fill(255);
          textSize(32);
          textAlign(CENTER, CENTER);
          text("Level " + gameState.level + " starting in " + countdownSeconds, width / 2, height / 2);
        }
      } else if (!gameState.playing) {
        fill(255);
        textSize(32);
        textAlign(CENTER, CENTER);
        text("Level " + gameState.level + ": Press any key to start", width / 2, height / 2);
      } else {
        const level = levels[gameState.level];
        const progressFunction = level.progressFunction;
        const progress = progressFunction(metrics);
        if (progress >= 1) {
          if (levels[gameState.level + 1]) {
            nextLevel();
          } else {
            endGame();
          }
          return;
        }
        if (progress != null) {
          fill(255);
          textSize(32);
          textAlign(CENTER, CENTER);
          drawProgressBar(progress);
        } else {
          fill(255);
          textSize(32);
          textAlign(CENTER, CENTER);
          text("Relevant body parts not detected", width / 2, height / 2);
        }
      }
    }

    function drawProgressBar(progress) {
      const barWidth = 200;
      const barHeight = 20;
      const barX = (width - barWidth) / 2;
      const barY = height - 50;

      // Draw the outline of the bar
      stroke(255);
      strokeWeight(2);
      fill(0);
      rect(barX, barY, barWidth, barHeight, 10);

      // Draw the bar itself
      fill(0, 255, 0);
      rect(barX, barY, barWidth * progress, barHeight, 10);
    }

    function drawKeypoints(obj) {
      for (let j = 0; j < obj.keypoints.length; j++) {
        let keypoint = obj.keypoints[j];
        if (keypoint.confidence < 0.9) {
          continue;
        }
        fill(0, 255, 0);
        noStroke();
        circle(keypoint.x, keypoint.y, 10);
      }
    }
    function calculate2DDistance(point1, point2) {
      const dx = point1.x - point2.x;
      const dy = point1.y - point2.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function calculateHand3DDistance(point1, point2) {
      const dx = point1.x3D - point2.x3D;
      const dy = point1.y3D - point2.y3D;
      const dz = point1.z3D - point2.z3D;
      return Math.sqrt(dx * dx + dy * dy + dz * dz) * 100.;
    }

    function calculateBody3DDistance(point1, point2) {
      const dx = point1.keypoint3D.x - point2.keypoint3D.x;
      const dy = point1.keypoint3D.y - point2.keypoint3D.y;
      const dz = point1.keypoint3D.z - point2.keypoint3D.z;
      return Math.sqrt(dx * dx + dy * dy + dz * dz) * 100.;
    }

    function calculateFace3DDistance(point1, point2) {
      // I think this is a little funny, or at least maybe should only be used for ratios.
      // not sure how to interpret z.
      const dx = point1.x - point2.x;
      const dy = point1.y - point2.y;
      const dz = point1.z - point2.z;
      return Math.sqrt(dx * dx + dy * dy + dz * dz) * 100.;
    }

    function calculateFaceAveragePoint(point1, point2) {
      const x = (point1.x + point2.x) / 2;
      const y = (point1.y + point2.y) / 2;
      const z = (point1.z + point2.z) / 2;
      return { x, y, z };
    }

    // function calculateFace3DDistance(point1, point2) {
    //   const dx = point1.x - point2.x;
    //   const dy = point1.y - point2.y;
    //   const dz = point1.z - point2.z;
    //   return Math.sqrt(dx * dx + dy * dy + dz * dz) * 100.;
    // }

    function drawDistanceBox(distanceStrs) {
      // Box parameters
      const padding = 10;
      const lineHeight = 24;
      const boxWidth = 300;
      const boxHeight = padding * 2 + lineHeight * distanceStrs.length;
      const boxX = 20;
      const boxY = 20;

      // Draw box with semi-transparent background
      push();
      fill(0, 0, 0, 230);    // More opaque background
      stroke(255, 255, 0);   // Yellow border
      strokeWeight(3);       // Thicker border
      rect(boxX, boxY, boxWidth, boxHeight, 10);  // Rounded corners

      // Draw text
      fill(255);             // White text
      noStroke();
      textSize(20);          // Text size
      textAlign(LEFT, TOP);

      // Show each distance string
      for (let i = 0; i < distanceStrs.length; i++) {
        text(distanceStrs[i], boxX + padding, boxY + padding + i * lineHeight);
      }
      pop();
    }

    function drawHandSkeleton(hand) {
      // Define finger connections
      const fingerConnections = [
        // Thumb [connections]
        [0, 1, 2, 3, 4],
        // Index finger 
        [0, 5, 6, 7, 8],
        // Middle finger
        [0, 9, 10, 11, 12],
        // Ring finger
        [0, 13, 14, 15, 16],
        // Pinky
        [0, 17, 18, 19, 20]
      ];

      // Define colors for each finger
      const colors = [
        [255, 0, 0],      // thumb (red)
        [0, 255, 0],      // index (green)
        [0, 0, 255],      // middle (blue)
        [255, 255, 0],    // ring (yellow)
        [255, 0, 255]     // pinky (magenta)
      ];

      // Draw each finger
      for (let i = 0; i < fingerConnections.length; i++) {
        const points = fingerConnections[i];
        const color = colors[i];

        stroke(color[0], color[1], color[2]);
        strokeWeight(2);

        // Draw lines connecting each point in the finger
        for (let j = 0; j < points.length - 1; j++) {
          const keypoint1 = hand.keypoints[points[j]];
          const keypoint2 = hand.keypoints[points[j + 1]];

          if (keypoint1 && keypoint2) {
            line(keypoint1.x, keypoint1.y, keypoint2.x, keypoint2.y);
          }
        }
      }
    }

    function resetGame() {
      gameState.started = false;
      gameState.level = 1;
      gameState.ended = false;
      gameState.countdown = false;
      gameState.playing = false;
    }

    function startGame() {
      gameState.started = true;
    }

    function endGame() {
      gameState.ended = true;
    }

    function startLevel() {
      gameState.playing = true;
    }

    function startCountdown() {
      gameState.countdown = true;
      gameState.countdownStartTime = millis();
    }

    function nextLevel() {
      gameState.level++;
      gameState.playing = false;
      startCountdown();
    }

    function keyPressed() {
      if (gameState.playing || gameState.countdown) {
        return;
      }
      if (!gameState.started) {
        startGame();
        startCountdown();
      }
      else if (gameState.ended) {
        resetGame();
      }
      else {
        startCountdown();
      }
    }
  </script>
</body>

</html>